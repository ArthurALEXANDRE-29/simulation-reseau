/**
 * Programme principal de simulation r√©seau
 * 
 * Ce fichier contient le programme principal qui simule un r√©seau
 * commut√© avec le protocole STP. Il permet de :
 * - Cr√©er une topologie de test
 * - Initialiser les switches et stations
 * - Ex√©cuter le protocole STP
 * - Simuler l'envoi de trames
 * - Afficher l'√©tat du r√©seau
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>
#include "switch.h"
#include "stp.h"
#include "graphe.h"
#include "adresse.h"
#include "trame.h"
#include "station.h"

/**
 * Structure pour simuler des stations connect√©es aux switches
 * 
 * Cette structure √©tend la structure station_t avec des informations
 * sur la connexion physique au r√©seau :
 * - nom : identifiant lisible de la station
 * - switch_id : identifiant du switch connect√©
 * - port_connecte : num√©ro du port sur le switch
 */
typedef struct {
    station_t station;
    char nom[32];
    int switch_id;
    int port_connecte;
} station_connectee_t;

/**
 * Cr√©e une topologie de test en forme de triangle
 * 
 * Cette fonction cr√©e une topologie simple avec 3 switches
 * connect√©s en triangle, utilis√©e pour tester le protocole STP.
 * 
 * Retourne un pointeur vers le graphe cr√©√©, NULL en cas d'erreur
 */
graphe* creer_topologie_triangle() {
    graphe *g = malloc(sizeof(graphe));
    if (!g) return NULL;
    
    init_graphe(g);
    
    // Ajouter 3 sommets (switches)
    ajouter_sommet(g);  // Switch 0
    ajouter_sommet(g);  // Switch 1
    ajouter_sommet(g);  // Switch 2
    
    // Cr√©er un triangle (chaque switch connect√© aux deux autres)
    arete a1 = {0, 1};
    arete a2 = {1, 2};
    arete a3 = {2, 0};
    
    ajouter_arete(g, a1);  // SW0 <-> SW1
    ajouter_arete(g, a2);  // SW1 <-> SW2
    ajouter_arete(g, a3);  // SW2 <-> SW0
    
    return g;
}

/**
 * Initialise les switches de test
 * 
 * Cette fonction initialise 3 switches avec des priorit√©s
 * diff√©rentes pour tester la s√©lection de la racine STP :
 * - Switch 0 : priorit√© haute (100)
 * - Switch 1 : priorit√© moyenne (200)
 * - Switch 2 : priorit√© basse (300)
 */
void init_switches_test(switch_t switches[], int nb_switches) {
    // Switch 0 - Priorit√© haute (sera probablement root)
    switches[0] = creer_switch(creer_mac(0x00, 0x01, 0x02, 0x03, 0x04, 0x05), 3, 100);
    
    // Switch 1 - Priorit√© moyenne
    switches[1] = creer_switch(creer_mac(0x00, 0x01, 0x02, 0x03, 0x04, 0x06), 3, 200);
    
    // Switch 2 - Priorit√© basse
    switches[2] = creer_switch(creer_mac(0x00, 0x01, 0x02, 0x03, 0x04, 0x07), 3, 300);
    
    // Activer tous les ports avec co√ªt 10
    for (int i = 0; i < nb_switches; i++) {
        for (int p = 0; p < switches[i].nb_ports; p++) {
            activer_port(&switches[i], p);
            switches[i].ports[p].cost = 10;
        }
    }
}

/**
 * Initialise les stations de test
 * 
 * Cette fonction initialise 3 stations connect√©es √† des
 * switches diff√©rents pour tester la communication :
 * - Station A : connect√©e au switch 0
 * - Station B : connect√©e au switch 1
 * - Station C : connect√©e au switch 2
 */
void init_stations_test(station_connectee_t stations[], int nb_stations) {
    // Station A connect√©e au switch 0, port 0
    stations[0].station = creer_station(
        creer_mac(0x10, 0x10, 0x10, 0x10, 0x10, 0x10),
        creer_ip(192, 168, 1, 10)
    );
    strcpy(stations[0].nom, "Station_A");
    stations[0].switch_id = 0;
    stations[0].port_connecte = 0;
    
    // Station B connect√©e au switch 1, port 0
    stations[1].station = creer_station(
        creer_mac(0x20, 0x20, 0x20, 0x20, 0x20, 0x20),
        creer_ip(192, 168, 1, 20)
    );
    strcpy(stations[1].nom, "Station_B");
    stations[1].switch_id = 1;
    stations[1].port_connecte = 0;
    
    // Station C connect√©e au switch 2, port 0
    stations[2].station = creer_station(
        creer_mac(0x30, 0x30, 0x30, 0x30, 0x30, 0x30),
        creer_ip(192, 168, 1, 30)
    );
    strcpy(stations[2].nom, "Station_C");
    stations[2].switch_id = 2;
    stations[2].port_connecte = 0;
}

/**
 * Affiche l'√©tat du r√©seau apr√®s l'ex√©cution de STP
 * 
 * Cette fonction affiche de mani√®re format√©e :
 * - Les informations de chaque switch
 * - L'√©tat et le r√¥le de chaque port
 * - La table de commutation de chaque switch
 */
void afficher_etat_reseau(switch_t switches[], int nb_switches, graphe *g) {
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    √âTAT DU R√âSEAU APR√àS STP                  ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    for (int i = 0; i < nb_switches; i++) {
        printf("\n‚îå‚îÄ Switch %d ", i);
        char mac_str[18];
        MAC_to_string(switches[i].mac, mac_str);
        printf("(%s) - Priorit√©: %d\n", mac_str, switches[i].priorite);
        
        printf("‚îú‚îÄ Ports:\n");
        for (int p = 0; p < switches[i].nb_ports; p++) {
            printf("‚îÇ  Port %d: %-12s - %-12s - Co√ªt: %d\n", p,
                   port_role_to_string(get_port_role(&switches[i], p)),
                   port_state_to_string(get_port_state(&switches[i], p)),
                   switches[i].ports[p].cost);
        }
        
        printf("‚îî‚îÄ Table de commutation:\n");
        if (switches[i].table.taille > 0) {
            for (int t = 0; t < switches[i].table.taille; t++) {
                char mac_entry[18];
                MAC_to_string(switches[i].table.entrees[t].mac, mac_entry);
                printf("   %s -> Port %d\n", mac_entry, switches[i].table.entrees[t].port);
            }
        } else {
            printf("   (vide)\n");
        }
    }
}

/**
 * Simule l'envoi d'une trame dans le r√©seau
 * 
 * Cette fonction simule le traitement d'une trame par un switch :
 * 1. Cr√©ation de la trame
 * 2. V√©rification de l'√©tat du port d'entr√©e
 * 3. Apprentissage de l'adresse source
 * 4. Recherche de l'adresse destination
 * 5. D√©cision de forwarding (unicast, broadcast ou flood)
 */
void simuler_envoi_trame(switch_t switches[], int nb_switches, graphe *g,
                        MAC src_mac, MAC dst_mac, const char* message,
                        int switch_entree, int port_entree) {
    
    printf("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n");
    printf("‚îÇ SIMULATION D'ENVOI DE TRAME                                 ‚îÇ\n");
    printf("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
    
    // Cr√©er la trame
    trame t;
    uint8_t *data = (uint8_t*)message;
    if (!init_trame(&t, src_mac, dst_mac, TYPE_IPV4, data, strlen(message))) {
        printf("Erreur lors de la cr√©ation de la trame\n");
        return;
    }
    
    // Calculer et assigner le FCS
    t.fcs = calculer_fcs(&t);
    
    printf("Trame cr√©√©e:\n");
    afficher_trame(&t);
    printf("\n");
    
    // Traitement par le switch d'entr√©e
    printf("‚ïê‚ïê‚ïê Traitement par Switch %d ‚ïê‚ïê‚ïê\n", switch_entree);
    
    // V√©rifier l'√©tat du port d'entr√©e
    if (get_port_state(&switches[switch_entree], port_entree) != PORT_FORWARDING) {
        printf("‚ùå Port %d du switch %d n'est pas en √©tat FORWARDING\n", 
               port_entree, switch_entree);
        printf("   √âtat actuel: %s\n", 
               port_state_to_string(get_port_state(&switches[switch_entree], port_entree)));
        deinit_trame(&t);
        return;
    }
    
    // Apprentissage de l'adresse source
    printf("üìö Apprentissage: ");
    char src_str[18];
    MAC_to_string(src_mac, src_str);
    printf("%s -> Port %d\n", src_str, port_entree);
    ajouter_entree_table(&switches[switch_entree].table, src_mac, port_entree);
    
    // Recherche de l'adresse de destination
    int port_destination = chercher_port_mac(&switches[switch_entree].table, dst_mac);
    
    char dst_str[18];
    MAC_to_string(dst_mac, dst_str);
    
    if (est_broadcast(dst_mac)) {
        printf("üì¢ Adresse broadcast d√©tect√©e\n");
        printf("üîÑ Flood sur tous les ports actifs sauf port d'entr√©e %d:\n", port_entree);
        
        for (int p = 0; p < switches[switch_entree].nb_ports; p++) {
            if (p != port_entree && 
                get_port_state(&switches[switch_entree], p) == PORT_FORWARDING &&
                port_est_actif(&switches[switch_entree], p)) {
                printf("   ‚úÖ Port %d: %s\n", p, 
                       port_role_to_string(get_port_role(&switches[switch_entree], p)));
            } else if (p != port_entree) {
                printf("   ‚ùå Port %d: %s (%s)\n", p,
                       port_role_to_string(get_port_role(&switches[switch_entree], p)),
                       port_state_to_string(get_port_state(&switches[switch_entree], p)));
            }
        }
    } else if (port_destination == -1) {
        printf("‚ùì Adresse destination %s inconnue\n", dst_str);
        printf("üîÑ Flood sur tous les ports actifs sauf port d'entr√©e %d:\n", port_entree);
        
        for (int p = 0; p < switches[switch_entree].nb_ports; p++) {
            if (p != port_entree && 
                get_port_state(&switches[switch_entree], p) == PORT_FORWARDING &&
                port_est_actif(&switches[switch_entree], p)) {
                printf("   ‚úÖ Port %d: %s\n", p,
                       port_role_to_string(get_port_role(&switches[switch_entree], p)));
            } else if (p != port_entree) {
                printf("   ‚ùå Port %d: %s (%s)\n", p,
                       port_role_to_string(get_port_role(&switches[switch_entree], p)),
                       port_state_to_string(get_port_state(&switches[switch_entree], p)));
            }
        }
    } else if (port_destination == port_entree) {
        printf("üîÑ Port de destination = port d'entr√©e (%d), trame ignor√©e\n", port_entree);
    } else {
        printf("üéØ Destination trouv√©e: %s -> Port %d\n", dst_str, port_destination);
        if (get_port_state(&switches[switch_entree], port_destination) == PORT_FORWARDING &&
            port_est_actif(&switches[switch_entree], port_destination)) {
            printf("‚úÖ Envoi direct sur port %d (%s)\n", port_destination,
                   port_role_to_string(get_port_role(&switches[switch_entree], port_destination)));
        } else {
            printf("‚ùå Port %d non disponible (%s, %s)\n", port_destination,
                   port_role_to_string(get_port_role(&switches[switch_entree], port_destination)),
                   port_state_to_string(get_port_state(&switches[switch_entree], port_destination)));
        }
    }
    
    deinit_trame(&t);
}

/**
 * Fonction principale du programme
 * 
 * Cette fonction :
 * 1. Cr√©e une topologie de test
 * 2. Initialise les switches et stations
 * 3. Ex√©cute le protocole STP
 * 4. Affiche l'√©tat du r√©seau
 * 5. Simule l'envoi de trames
 * 
 * Retourne 0 en cas de succ√®s, 1 en cas d'erreur
 */
int main() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë              SIMULATION DE R√âSEAU AVEC STP                     ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    
    // Cr√©er la topologie
    graphe *g = creer_topologie_triangle();
    if (!g) {
        printf("Erreur lors de la cr√©ation du graphe\n");
        return 1;
    }
    
    // Initialiser les switches
    const int NB_SWITCHES = 3;
    switch_t switches[NB_SWITCHES];
    init_switches_test(switches, NB_SWITCHES);
    
    // Initialiser les structures STP
    switch_stp_t stp_switches[NB_SWITCHES];
    for (int i = 0; i < NB_SWITCHES; i++) {
        init_stp(&stp_switches[i], &switches[i]);
    }
    
    printf("üèóÔ∏è  Topologie cr√©√©e: Triangle de 3 switches\n");
    printf("üìä Calcul du Spanning Tree Protocol...\n\n");
    
    // Calculer le STP
    calculer_stp_simple(stp_switches, NB_SWITCHES, g);
    
    // Afficher l'√©tat du r√©seau
    afficher_etat_reseau(switches, NB_SWITCHES, g);
    
    // Cr√©er des stations de test
    const int NB_STATIONS = 3;
    station_connectee_t stations[NB_STATIONS];
    init_stations_test(stations, NB_STATIONS);
    
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    STATIONS CONNECT√âES                       ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    for (int i = 0; i < NB_STATIONS; i++) {
        char mac_str[18];
        MAC_to_string(stations[i].station.mac, mac_str);
        printf("üñ•Ô∏è  %s (%s) -> Switch %d, Port %d\n", 
               stations[i].nom, mac_str, stations[i].switch_id, stations[i].port_connecte);
    }
    
    // Tests de communication
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    TESTS DE COMMUNICATION                    ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    // Test 1: Station A envoie √† Station B
    printf("\nüß™ TEST 1: Station_A -> Station_B\n");
    simuler_envoi_trame(switches, NB_SWITCHES, g,
                       stations[0].station.mac, stations[1].station.mac, "Hello Station B!",
                       stations[0].switch_id, stations[0].port_connecte);
    
    // Test 2: Broadcast depuis Station C
    printf("\nüß™ TEST 2: Station_C -> Broadcast\n");
    MAC broadcast = creer_mac(0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);
    simuler_envoi_trame(switches, NB_SWITCHES, g,
                       stations[2].station.mac, broadcast, "Broadcast message!",
                       stations[2].switch_id, stations[2].port_connecte);
    
    // Afficher l'√©tat final des tables
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                  TABLES APR√àS TESTS                         ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    afficher_etat_reseau(switches, NB_SWITCHES, g);
    
    // Nettoyage
    for (int i = 0; i < NB_SWITCHES; i++) {
        deinit_stp(&stp_switches[i]);
        deinit_switch(&switches[i]);
    }
    deinit_graphe(g);
    free(g);
    
    printf("\n‚úÖ Simulation termin√©e avec succ√®s!\n");
    return 0;
}
